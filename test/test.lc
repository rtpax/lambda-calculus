recursion::
    Y := Lx.xx
::recursion

boolean::
    T := Lxy.x
    F := Lxy.y

    & := Lxy.xyF
    | := Lxy.xTy
    ~ := Lx.xFT
    ^ := Lxy.x(~y)y
::boolean

natural::
    0 := Lsz.z
    S := Lwsz.s(wsz)
    ; # ...= S(#-1) ; valid statement but not yet supported

    1 := S0
    2 := S1
    3 := S2
    4 := S3
    5 := S4
    6 := S5
    7 := S6
    8 := S7
    9 := S8
    `10 := S9
    `11 := S`10
    `12 := S`11
    `13 := S`12
    `14 := S`13
    `15 := S`14
    `16 := S`15
    `17 := S`16
    `18 := S`17
    `19 := S`18
    `20 := S`19

    Z := Lx.x(TF)T

    `Phi := Lpz.z(S(pT))(pT)
    P := Ln.n`Phi(Lz.z00)F

    - := Lab.bPa
    + := Lab.aSb
    * := Lab.a(bS)0
    ^ := Lab.b(*a)1

    `>= := Lxy.Z(xPy)
    `<= := Lxy.Z(yPx)
    = := Lxy.&(`>= xy)(`<= xy)
    < := Lxy.~(`>= xy)
    > := Lxy.~(`<= xy)

    `fact := LN`gen.ZN1(*N(`gen(-N1)`gen))
    `fact' := L`gen`N.ZN1(*N(`gen`gen(-N1)))

    ! => Ln.`fact`n`fact
    !' => Ln.`fact'`fact'`n

    `fib' := LGnpc.Zcp(GGp(+np)(-c1))
    `fib => Lc.`fib'`fib'01c

    d := Lab.+(*a`10)b
    D := Labc.+(*(dab)`10)c

    `32 := d32
    `fib(`12)

::natural


integer::

    0' := :natural:0
    S' := :natural:S
    P' := :natural:P
    Z' := :natural:Z

    -' := :natural:-
    +' := :natural:+
    *' := :natural:*
    ^' := :natural:^

    `>=' := :natural:`>=
    `<=' := :natural:`<=
    =' := :natural:=
    <' := :natural:<
    >' := :natural:>

    0 := Lz.z0'0'

    `pos? := La.~(Z'(aF))
    `neg? := La.~(Z'(aT))
    `nat? := La.Z'(aT)
    Z := La.&(Z'(aT))(Z'(aF))

    S := La.`nat?`a(Lz.z0'(S'(aF)))(Lz.z(P'(aT))0')
    P := La.`pos?`a(Lz.z0'(P'(aF)))(Lz.z(S'(aT))0')

    + := Lab.aFS(aTPb)
    - := La.Lz.z(aF)(aT) ; additive inverse -- not subtraction
    * := Lab.aF(+b)(aT(+(-b))0)

    `>= := Lab(`nat?`a
            (`nat?`b(`>='(aF)(bF))(T))
            (`nat?`b(F)(`<='(aT)(bT))))
    `<= := Lab(`nat?`a
            (`nat?`b(`<='(aF)(bF))(F))
            (`nat?`b(T)(`>='(aT)(bT))))    
    < := Lab(`nat?`a
            (`nat?`b(<'(aF)(bF))(F))
            (`nat?`b(T)(>'(aT)(bT))))
    > := Lab(`nat?`a
            (`nat?`b(>'(aF)(bF))(T))
            (`nat?`b(F)(<'(aT)(bT))))
    = := Lab(&(='(aF)(bF))(='(aT)(bT)))


    1 := S0
    2 := S1
    3 := S2
    4 := S3
    5 := S4
    6 := S5
    7 := S6
    8 := S7
    9 := S8
    `10 := S9
    `11 := S`10
    `12 := S`11
    `13 := S`12
    `14 := S`13
    `15 := S`14
    `16 := S`15
    `17 := S`16
    `18 := S`17
    `19 := S`18
    `20 := S`19

    `-1 := P0
    `-2 := P`-1
    `-3 := P`-2
    `-4 := P`-3
    `-5 := P`-4
    `-6 := P`-5
    `-7 := P`-6
    `-8 := P`-7
    `-9 := P`-8
    `-10 := P`-9
    `-11 := P`-10
    `-12 := P`-11
    `-13 := P`-12
    `-14 := P`-13
    `-15 := P`-14
    `-16 := P`-15
    `-17 := P`-16
    `-18 := P`-17
    `-19 := P`-18
    `-20 := P`-19

    `fact := LN`gen.`pos? N(*N(`gen(+N(-1))`gen))1
    ! => Ln.`fact`n`fact

    !3
;::





boolean evaluate(A)
    switch(A.type)
    case lambda:
        return evaluate(A.out)
    case expr:
        if(A.head...head.type = lambda)
            if(tails_until_lambda(A) >= count_args(A.head...head.args))
                if(all_free(A.head...head.output))
                    if(evaluate_arguments(A))
                        return true
                    else if(evaluate_lambda(A))
                        return true
                    else if(evaluate)
        else // (A.head...head.type = id)
            if (NOT A.head...head.bound)
               expand(A.head...head) 
        return evaluate(A.tail)
    case id:
        if(bound(A))
            return false
        if(has_value(A))
            A.expand()
            return true
        return false



La.a((Lb.b)c) -> La.ac
La.(Lb.ab)c   -> La.ac
La.(Lb.b)ac   -> La.(Lb.b)ac
La.(Lb.bc)a   -> La.(Lb.bc)a

`fib := Lc.Y(LGnpc.Zcp(GGp(+np)(-c1)))01c
`fib := Lc.Y(LGnpc.(Lx.x(TF)T)cp(GGp((Lab.aSb)np)))01c

;::

                     /\
                    /\ z
                   /\ y
                  /  x
                 L-a
                 L-b
                 L-c
                 /\ 
                /\ c
               a  b 



::;




::integer



